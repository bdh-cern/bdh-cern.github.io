# Summary

- Retrieving the tune of the SPS is not easy because the H and V planes can be highly correlated and may contain a lot of noise.
- Anton Lu wrote a nice clustering script which looked at H, clustered it into two (one cluster for H, another for the correlated signal from V), selected the cluster which was likely to contain H considering that generally $Q_H > Q_V$, and took the modal frequency from that cluster as the value of $Q_H$. The same was done to get $Q_V$.
- This script was limited because it merged close-by clusters if their mean frequencies were similar. This comparison rarely returned true due to outliers, the low tolerance, etc.
- I replaced this clustering logic such that clusters are instead merged based on:
	- The distance between each cluster's modal frequency
	- The ratio of each cluster's greatest amplitude (such that groups were merged if one's peak dominated the other)
	- The size of the smaller cluster (such that smaller clusters with small peaks were merged into the larger cluster)
- This new approach nicely cleaned up the data from [[19-11-25 MD - Messy chroma analysis]]
- Improved it further by using a GA to find the best values for the clustering algorithm


# Development

This is a set of helpers, initially written by Anton Lu, the primary purpose of which is to correctly identify the correct peaks of the FFT of the BBQ data corresponding to $Q_H^{frac}$  and $Q_V^{frac}$. 

The process is:

![[1000000962.jpg]]

Comments on this:

- The clustering attempts to identify the regions around $Q_H$/$Q_V$ (higher/lower frequency). $Q_H$ is identified by finding the highest-amplitude signal within the cluster with the higher frequency.
	- This frequently results in the selection of a different signal compared to simply taking that of the highest amplitude (probably correctly)
- A value 'min_separation' is used to both a.) 1st pass: merge clusters in the same plane which are too close to one another and b.) 2nd pass: discard all results if the chosen H and V clusters are the same
	- The separation is the difference in centroid position (i.e. mean frequencies) of each cluster.
		- It's quite unlikely that this will work for comparing the H and V clusters. These are generated by two different sets of data and outlying points will easily stop the centroids being similar even if their modal values are.
	- The merging was not happening at all until I increased min_separation by an OoM for [[19-11-25 MD - Messy chroma analysis]]
	- If H and V are similar, this approach may destroy perfectly good data
		- It's probably unlikely that they are so similar, however.
- Could just use global k-means to find if 1 or 2 clusters is better?
- The temporal constraints actually do a lot to save the data.

## Global K-means

Switching to global k-means does not seem to improve things much on first glance:

Global:

![[Pasted image 20260108122832.png]]

Naive:

![[image(3).png]]

## Clustering Problems

Sometimes there ought only to be one cluster (in fact this is often ideal if the V signal does not show up on the H FFT). However, both clustering methods are quite zealous with creating two clusters. For example below (with global k-means) which clearly should only be one cluster. In this case $\sigma$ is greater for k=1 than k=2.

![[Pasted image 20260108124208.png]]

- Normalising sigma to size of largest cluster: doesn't work
- Giving up on global k-means (ideas to fix, such as penalising smallest group, but it's very slow to execute in any case)
- Comparing clusters via the modal frequencies: much nicer. However still get cases like this: 
	- ![[Pasted image 20260108132221.png]]
	- In this case I would like to merge the clusters when one modal amplitude is much larger than the other, however this is not yet working...
		- Working now if I check both the difference in amplitude and the group size. Just using amplitude resulted in some over-zealous merging which breaks things e.g. when, for the H data, the V peak actually has a higher amplitude
		- `if np.diff(modal_tunes)[0] < min_separation or (max(max_amplitudes)/min(max_amplitudes) > 10 and min(cluster_sizes) <= 5):`

# Example using modal frequencies:

Before: ![[image(3).png]]

After: ![[Pasted image 20260108144346.png]]


# Genetic Algorithm

- I used PyGAD to find some optimal values for max_cluster_amplitude_ratio, min_cluster_size, min_cluster_separation
- The GA runs twice: once for H and once for V
- The fitness of each individual is simply $-\Sigma_{cycle}(\sigma(Q))$  (sum of standard deviations)
- This did a very good job at automatically cleaning up the no-MD1 scan in [[19-11-25 MD - Messy chroma analysis]] automatically
- Before: ![[image(4).png]]
- After:![[image(5).png]]